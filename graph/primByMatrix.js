/**
 * Prim 算法（P算法）
 * 
 * 邻接矩阵的实现
 * 
 * 求解有权无向连通图的最小生成树。在图中，每个顶点可能被多条边连通，使用的边的权重之和如果最小，则成为最小生成树
 * 
 * 有权、无向、贪心
 * 
 * 一个用邻接矩阵表示的有权无向图如下
 * 
 * [
 *     A  B  C  D  E  F
 * A  [0, 2, 4, 0, 0, 0],
 * B  [2, 0, 2, 4, 2, 0],
 * C  [4, 2, 0, 0, 3, 0],
 * D  [0, 4, 0, 0, 3, 2],
 * E  [0, 2, 3, 3, 0, 2],
 * F  [0, 0, 0, 2, 2, 0]
 * ];
 * 
 * 跟 K 算法不同， P 算法是从顶点出发。由于是连通图，所有点都是连接的，所以从任一点出发都可以，我们从 A 点出发
 * 过程中需要记录两项数据
 * 1. 每个顶点的前置顶点
 * 2. 每个顶点与其前置顶点的距离
 * 3. 已处理完成的顶点
 * 
 * 过程如下：
 * 1. 初始化前置顶点和距离为无穷大
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    -  -  -  -  -  -
 *    前置    -  -  -  -  -  -
 *    已访问顶点 []
 * 
 * 2. 从 A 出发，则其前置顶点无，距离0
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  -  -  -  -  -
 *    前置    -  -  -  -  -  -
 *    已访问顶点 []
 * 
 * 3. 遍历所有未处理的顶点，找到距离最小的一个，找到了 A
 * 4. 找到 A 的所有相邻顶点（未处理完成的），若与 A 距离小于它所记录的最小距离，则记录它与 A 的距离
 * 5. 将 A 记录为已处理完成
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  2  4  -  -  -
 *    前置    -  A  A  -  -  -
 *    已访问顶点 [A]
 * 
 * 6. 重复 3、4、5
 * 
 * 3. 遍历所有未处理的顶点，找到距离最小的一个，找到了 B
 * 4. 找到 B 的所有相邻顶点（未处理完成的），若与 B 距离小于它所记录的最小距离，则记录它与 B 的距离
 *    （此时 C 记录的距离是 4，BC 距离为 2，则改为记录 2 且修改前置节点为 B）
 * 5. 将 B 记录为已处理完成
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  2  2  4  2  -
 *    前置    -  A  B  B  B  -
 *    已访问顶点 [A, B]
 * 
 * 6. 重复 3、4、5
 * 
 * 3. 遍历所有未处理的顶点，找到距离最小的一个，找到了 C 和 E，使用 E 来分析
 * 4. 找到 E 的所有相邻顶点（未处理完成的），若与 E 距离小于它所记录的最小距离，则记录它与 E 的距离
 *    （此时 D 记录的距离是 4，ED 距离为 3，则改为记录 3 且修改前置节点为 E）
 * 5. 将 E 记录为已处理完成
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  2  2  3  2  2
 *    前置    -  A  B  E  B  E
 *    已访问顶点 [A, B, E]
 * 
 * 3. 遍历所有未处理的顶点，找到距离最小的一个，找到了 C 和 F，使用 F 来分析
 * 4. 找到 F 的所有相邻顶点（未处理完成的），若与 F 距离小于它所记录的最小距离，则记录它与 F 的距离
 *    （此时 D 记录的距离是 3，FD 距离为 2，则改为记录 2 且修改前置节点为 F）
 * 5. 将 F 记录为已处理完成
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  2  2  2  2  2
 *    前置    -  A  B  F  B  E
 *    已访问顶点 [A, B, E, F]
 * 
 * 3. 遍历所有未处理的顶点，找到距离最小的一个，找到了 C 和 D，使用 C 来分析
 * 4. 找到 C 的所有相邻顶点（未处理完成的），若与 C 距离小于它所记录的最小距离，则记录它与 C 的距离
 *    （与 C 相邻的 A B E 顶点，距离都没有比所记录的距离小，所以不做修改）
 * 5. 将 C 记录为已处理完成
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  2  2  2  2  2
 *    前置    -  A  B  F  B  E
 *    已访问顶点 [A, B, E, F, C]
 * 
 * 3. 遍历所有未处理的顶点，找到距离最小的一个，找到了 D （只剩 D 了）
 * 4. 找到 D 的所有相邻顶点（未处理完成的），若与 D 距离小于它所记录的最小距离，则记录它与 D 的距离
 *    （与 D 相邻的 B E F 顶点，距离都没有比所记录的距离小，所以不做修改）
 * 5. 将 D 记录为已处理完成
 * 
 *    顶点    A  B  C  D  E  F
 *    距离    0  2  2  2  2  2
 *    前置    -  A  B  F  B  E
 *    已访问顶点 [A, B, E, F, C, D]
 * 
 * 7. 所有顶点遍历完成，输出每个顶点的前置顶点和距离如下
 * A - B  2
 * B - C  2
 * F - D  2
 * B - E  2
 * E - F  2
 * 转为下标显示即
 * 0 - 1  2
 * 1 - 2  2
 * 5 - 3  2
 * 1 - 4  2
 * 4 - 5  2
 * 跟预期一致
 * 
 * 8. 输出新的邻接矩阵图
 * [
 *   [ 0, 2, 0, 0, 0, 0 ],
 *   [ 2, 0, 2, 0, 2, 0 ],
 *   [ 0, 2, 0, 0, 0, 0 ],
 *   [ 0, 0, 0, 0, 0, 2 ],
 *   [ 0, 2, 0, 0, 0, 2 ],
 *   [ 0, 0, 0, 2, 2, 0 ]
 * ]
 * 
 */
module.exports = primByMatrix = graph => {
  // 已访问顶点集合
  const visited = [];
  // 预期达到最小生成树后，每个顶点的前置顶点集合
  const parents = [];
  // 预期达到最小生成树后，每个顶点与其前置顶点的距离集合
  const distances = [];

  // 1. 初始化前置顶点和距离为无穷大
  for (let i = 0; i < graph.length; i++) {
    parents[i] = null;
    distances[i] = Infinity;
  }

  // 2. 从 A 出发，则其前置顶点无，距离0
  distances[0] = 0;

  // 6. 重复 3、4、5
  for (let i = 0; i < graph.length; i++) {
    // 3. 遍历所有未处理的顶点，找到距离最小的一个
    const target = getMin(distances, visited);
    for (let k = 0; k < graph.length; k++) {
      // 4. 找到 目标顶点 的所有相邻顶点（未处理完成的），若与 A 距离小于它所记录的最小距离，则记录它与 A 的距离
      if (!visited[k] && graph[target][k] && graph[target][k] < distances[k]) {
        distances[k] = graph[target][k];
        parents[k] = target;
      }
    }
    // 5. 将 目标顶点 记录为已处理完成
    visited[target] = true;
  }

  // 7. 所有顶点遍历完成，输出每个顶点的前置顶点和距离如下
  graph.forEach((v, i) => {
    console.log(`${parents[i]} - ${i} -> ${distances[i]}`);
  })


  // 根据最小生成树的边，生成一个新的图并返回
  const newGraph = [];
  graph.forEach(() => {
    newGraph.push(new Array(graph.length).fill(0));
  })
  parents.forEach((p, i) => {
    if (p !== null && i !== null) {
      newGraph[p][i] = newGraph[i][p] = graph[i][p];
    }
  })
  return newGraph;
}

function getMin(distances, visited) {
  let minTarget = null;
  let minTemp = Infinity;
  distances.forEach((v, i) => {
    if (!visited[i] && distances[i] < minTemp) {
      minTemp = distances[i];
      minTarget = i;
    }
  })
  return minTarget;
}

// 测试代码
const graphForP = [
  [0, 2, 4, 0, 0, 0],
  [2, 0, 2, 4, 2, 0],
  [4, 2, 0, 0, 3, 0],
  [0, 4, 0, 0, 3, 2],
  [0, 2, 3, 3, 0, 2],
  [0, 0, 0, 2, 2, 0]
];

console.log('primByMatrix:', primByMatrix(graphForP));
